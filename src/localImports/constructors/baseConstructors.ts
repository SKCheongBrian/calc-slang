// import cs from 'estree'
import * as cs from '../../tree/ctree'

// Note that typecasting is done on some of the constructed AST nodes because
// the ESTree AST node types are not fully aligned with the actual AST that
// is generated by the Acorn parser. However, the extra/missing properties
// are unused in the Source interpreter/transpiler. As such, we can safely
// ignore their existence to make the typing cleaner. The alternative would
// be to define our own AST node types based off the ESTree AST node types
// and use our custom AST node types everywhere.

export const createLiteral = (
  value: string | number | boolean | null,
  raw?: string
): cs.Literal => {
  return {
    type: 'Literal',
    value,
    raw: raw ?? typeof value === 'string' ? `"${value}"` : String(value)
  }
}

export const createIdentifier = (name: string): cs.Identifier => {
  return {
    type: 'Identifier',
    name
  }
}

export const createCallExpression = (
  functionName: string,
  functionArguments: Array<cs.Expression | cs.SpreadElement>
): cs.SimpleCallExpression => {
  return {
    type: 'CallExpression',
    callee: createIdentifier(functionName),
    arguments: functionArguments
    // The 'optional' property is typed in ESTree, but does not exist
    // on SimpleCallExpression nodes in the AST generated by acorn parser.
  } as cs.SimpleCallExpression
}

export const createVariableDeclarator = (
  id: cs.Identifier,
  initialValue: cs.Expression | null | undefined = null
): cs.VariableDeclarator => {
  return {
    type: 'VariableDeclarator',
    id,
    init: initialValue
  }
}

export const createVariableDeclaration = (
  declarations: cs.VariableDeclarator[],
  kind: 'var' | 'let' | 'const'
): cs.VariableDeclaration => {
  return {
    type: 'VariableDeclaration',
    declarations,
    kind
  }
}

export const createReturnStatement = (
  argument: cs.Expression | null | undefined
): cs.ReturnStatement => {
  return {
    type: 'ReturnStatement',
    argument
  }
}

export const createFunctionDeclaration = (
  name: string,
  params: cs.Pattern[],
  body: cs.Statement[]
): cs.FunctionDeclaration => {
  return {
    type: 'FunctionDeclaration',
    expression: false,
    generator: false,
    id: {
      type: 'Identifier',
      name
    },
    params,
    body: {
      type: 'BlockStatement',
      body
    }
    // The 'expression' property is not typed in ESTree, but it exists
    // on FunctionDeclaration nodes in the AST generated by acorn parser.
  } as cs.FunctionDeclaration
}

export const createImportDeclaration = (
  specifiers: Array<cs.ImportSpecifier | cs.ImportDefaultSpecifier | cs.ImportNamespaceSpecifier>,
  source: cs.Literal
): cs.ImportDeclaration => {
  return {
    type: 'ImportDeclaration',
    specifiers,
    source
  }
}

export const createImportSpecifier = (
  local: cs.Identifier,
  imported: cs.Identifier
): cs.ImportSpecifier => {
  return {
    type: 'ImportSpecifier',
    local,
    imported
  }
}

export const createImportDefaultSpecifier = (local: cs.Identifier): cs.ImportDefaultSpecifier => {
  return {
    type: 'ImportDefaultSpecifier',
    local
  }
}

export const createImportNamespaceSpecifier = (
  local: cs.Identifier
): cs.ImportNamespaceSpecifier => {
  return {
    type: 'ImportNamespaceSpecifier',
    local
  }
}
